<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test mult push]]></title>
    <url>%2F2020%2F03%2F16%2Ftest-mult-push%2F</url>
    <content type="text"><![CDATA[test test]]></content>
  </entry>
  <entry>
    <title><![CDATA[java中的零拷贝]]></title>
    <url>%2F2019%2F09%2F13%2Fzero-copy%2F</url>
    <content type="text"><![CDATA[许多web应用提供大量的静态内容，主要是从磁盘中读取数据染回将数据写到套接字中，通过网络发送出去。这其中并不涉及到数据的变化。这种场景就比较适合使用零拷贝。零拷贝可以直接将数据读到内存之后，直接写到socket的channel中，减少了数据从内核态拷贝回用户态，再从用户态拷贝回内核态带来的性能损失。 正常操作从磁盘中读取数据发送出去，或者读取数据然后写到另外一个位置，不对数据本身做任何处理 需要进行如下几个步骤： java虚拟机通过用户空间调用底层read()请求，请求发给内核空间，这个时候会发生从用户空间模式到内核空间模式的切换。 切换到内核空间模式就可以进行磁盘硬件的访问了，通过dma(直接内存访问 )技术，读取数据，并保存在内核状态的一个缓冲区中 将内核空间缓冲区中的内容copy到用户空间缓冲区，这个时候就完成了读取的操作 Write操作的时候，会先将数据读到用户态的缓冲区中，然后copy到内核态的缓冲区中，最后通过内核态输出到硬件 整个过程中会进行四次用户空间和内核空间的交互，还会进行两次没意义的内存拷贝，因为这里用户空间只是做为临时的数据拷贝，并没起到其他的作用。数据的交互起始都是在内核空间完成的。 用户空间的零拷贝 用户空间不必作为临时的数据中转，直接在内核空间中进行数据的复制。 用户空间不需要参与到数据的交互。如果使用内存映射的方式将数据加载到内存中，可以对数据进行修改。内存映射的方式是直接将文件映射到内核空间，所以这个时候也不会产生从用户空间到内核空间的切换。(但是在数据发送之前，还是需要在内核空间内进行数据的复制) 用户空间通过sendfile()请求，切换到内核空间 内核空间读取数据到内核空间缓冲区中 将缓冲区中的数据写到输出目标的缓冲区中 输出到硬件 代码演示 服务端代码 12345678910111213141516171819202122public static void main(String[] args) throws Exception&#123; InetSocketAddress inetSocketAddress = new InetSocketAddress(8899); ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); ServerSocket serverSocket = serverSocketChannel.socket(); serverSocket.setReuseAddress(true); serverSocket.bind(inetSocketAddress); ByteBuffer buffer = ByteBuffer.allocate(4096); while (true) &#123; SocketChannel socketChannel = serverSocketChannel.accept(); socketChannel.configureBlocking(true); int readCount = 0; while (-1 != readCount) &#123; try &#123; readCount = socketChannel.read(buffer); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; buffer.rewind(); &#125; &#125; &#125; 老的客户端 123456789101112131415161718192021222324252627public class OldIOClient &#123; public static void main(String[] args) throws Exception&#123; Socket socket = new Socket("localhost", 8899); // 一个大 String fileName = "/Users/xiejunhua/Downloads/未命名文件夹/2019-04-08-raspbian-stretch-full.zip"; InputStream inputStream = new FileInputStream(fileName); DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream()); byte[] buffer = new byte[4096]; long readCoun; long total = 0; long startTime = System.currentTimeMillis(); while ((readCoun = inputStream.read(buffer)) &gt;= 0) &#123; total += readCoun; dataOutputStream.write(buffer); &#125; System.out.println("发送总字节数: " + total + ", 耗时: " + (System.currentTimeMillis() - startTime)); dataOutputStream.close(); socket.close(); inputStream.close(); &#125;&#125; 老的客户端代码执行时间: 新的客户端代码: 12345678910111213141516public class NewIOClient &#123; public static void main(String[] args) throws Exception&#123; SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress("localhost", 8899)); socketChannel.configureBlocking(true); String fileName = "/Users/xiejunhua/Downloads/未命名文件夹/2019-04-08-raspbian-stretch-full.zip"; FileChannel fileChannel = new FileInputStream(fileName).getChannel(); long startTime = System.currentTimeMillis(); // 将数据之间发送到socketChannel中 long transferCount = fileChannel.transferTo(0, fileChannel.size(), socketChannel); System.out.println("发送总字节数: " + transferCount + ", 耗时: " + (System.currentTimeMillis() - startTime)); fileChannel.close(); &#125;&#125; 新的客户端代码执行的时间: 结果可以很明显的看到，使用了零拷贝的代码在效率上有很大的提升。 真正意义上的零拷贝进一步减少数据在内核空间内的拷贝和 复制 文件从用户空间拷贝到内核空间 将拷贝到内核空间的数据的文件描述符的信息被copy到socket buffer中，而不需要拷贝整个数据。文件描述符号包含两部分信息(kernel buffer内存地址，和kernel buffer的长度) 协议引擎负责发送数据，从socket buffer中读取到kernel buffer的文件描述符信息，然后直接从kernel buffer中读取数据直接发送。从两个buffer中读取数据的操作就是一种gather操作]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>NIO</tag>
        <tag>零拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask应用整合uWsgi,nginx,supervisor]]></title>
    <url>%2F2019%2F09%2F09%2Ftest1%2F</url>
    <content type="text"><![CDATA[本文使用uWsgi,supervisor,nginx来构建一个简单的python web程序，尽可能的模拟实际生产环境中的一些状况。 Flask应用新建一个简单的run.py 123456789101112from flask import Flask, escape, requestapp = Flask(__name__)@app.route('/')def hello(): name = request.args.get("name", "World") return f'Hello, &#123;escape(name)&#125;!'#注意这里一定要将我们自己的启动方式放到main中，否则在uwsgi启动的时候会启动两个端口，uwsgi的socket的端口，和这里的8088端口if __name__ == '__main__': app.run(host='0.0.0.0', port=8088, debug=True) python文件写好了之后，直接执行python run.py 然后在浏览器中访问{yourip}:8088 uwsgiuwsgi是一个web容器，使你的python web app更加健壮，性能更好。相当于tomcat之于java web。你自己写一个servlet的web服务虽然也能跑，但是性能肯定不好。 当然uwsgi的好处还有很多，用途也有很多，具体可以参考官网 安装uwsgi依赖pip install uwsgi，这里需要注意，如果你是用虚环境启动的web服务，那么需要将uwsgi安装到虚环境中，这里建议在线上或者测试环境部署的时候都使用虚环境，python3.5之后可以通过自带的命令建虚环境python3 -m venv myenv，然后就会帮你把虚环境建好，到myenv/bin下面执行你的Python或者pip操作。 supervisorsupervisor是一个进程控制系统，我们可以通过sueprvisor启动我们的后端服务，这样一旦后端服务挂掉了，supervisor就会再次将服务启动起来，不至于长时间影响线上的服务。这里我们使用的时候并没有开启web端，更多详细操作和配置可以在官网了解 安装yum install supervisor 配置supervisor123456789101112131415161718192021222324252627282930313233343536373839404142434445; Sample supervisor config file.[unix_http_server]file=/var/run/supervisor/supervisor.sock ; (the path to the socket file);chmod=0700 ; sockef file mode (default 0700);chown=nobody:nogroup ; socket file uid:gid owner;username=user ; (default is no username (open server));password=123 ; (default is no password (open server));[inet_http_server] ; inet (TCP) server disabled by default;port=127.0.0.1:9001 ; (ip_address:port specifier, *:port for all iface);username=user ; (default is no username (open server));password=123 ; (default is no password (open server))[supervisord]logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)logfile_maxbytes=50MB ; (max main logfile bytes b4 rotation;default 50MB)logfile_backups=10 ; (num of main logfile rotation backups;default 10)loglevel=info ; (log level;default info; others: debug,warn,trace)pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)nodaemon=false ; (start in foreground if true;default false)minfds=1024 ; (min. avail startup file descriptors;default 1024)minprocs=200 ; (min. avail process descriptors;default 200);umask=022 ; (process file creation umask;default 022);user=chrism ; (default is current user, required if root);identifier=supervisor ; (supervisord identifier, default is &apos;supervisor&apos;);directory=/tmp ; (default is not to cd during start);nocleanup=true ; (don&apos;t clean up tempfiles at start;default false);childlogdir=/tmp ; (&apos;AUTO&apos; child log dir, default $TEMP);environment=KEY=value ; (key value pairs to add to environment);strip_ansi=false ; (strip ansi escape codes in logs; def. false); the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl=unix:///var/run/supervisor/supervisor.sock ; use a unix:// URL for a unix socket;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket;username=chris ; should be same as http_username if set;password=123 ; should be same as http_password if set;prompt=mysupervisor ; cmd line prompt (default &quot;supervisor&quot;);history_file=~/.sc_history ; use readline history if available 注意要注释掉unix_http_server中的username和password这些配置，否则在启动应用的时候会要求你配置用户名和密码。这里我们也注掉了不需要的url服务。 添加应用配置安装完成之后，可以将我们的配置添加到/etc/supervisord.d目录中 新建文件example.ini 1234567891011[program:example]command=/root/flask_web_app/bin/uwsgi --socket 127.0.0.1:3032 --plugin python --wsgi-file run.py --callable app -H /root/flask_web_appdirectory=/root/flask_web_app/example_appuser=rootautostart=trueautorestart=truestartretries=1stdout_logfile=/root/logs/supervisor_out1.logstderr_logfile=/root/logs/supervisor_err1.log command是程序的启动命令，要注意，这里不要将启动命令放到一个nohup的脚本中，会导致supervisor无法监控他的状态，因为nohup启的是另外一个进程，而supervisor监控的是nohup的进程。 uwsgi命令参数说明： /root/flask_web_app/bin/uwsgi 是虚环境中uwsgi的路径 --socket 127.0.0.1:3032 表示建立连接的端口 --wsgi-file run.py 启动脚本的名字 --callable app 这里的app和你在run.py中定义的app = Flask(__name__)保持一致 -H /root/flask_web_app 这里是指定虚环境的地址，这个很重要，一定要指定到虚环境的地址，否则在启动的时候是无法在你本机的python环境中找到你需要的一些依赖的 启动服务应用配置完成之后，就可以启动我们的supervisor服务了 service supervisord start默认会加载/etc/supervisor.conf的配置文件启动supervisor 启动完成之后，查看我们应用的状态 123456supervisorctl status all #查看状态supervisorctl start examplesupervisorctl restart examplesupervisorctl stop examplesupervisorctl update # 更新新的配置文件到supervisorsupervisorctl reload # 重新启动配置中的所有程序 running状态就表示我们的服务是正常启动的。 nginx 配置nginx 安装yum install nginx nginx配置可以选择直接在vi /etc/nginx/nginx.conf修改，也可以在/etc/nginx/nginx.d/目录中添加配置文件 这里我们直接在nginx.conf文件中做修改 123456789101112131415161718192021server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:3031; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 这里我们改动的位置只有location /里面的配置，注意这里的3031端口要和你启动的uwsgi的应用端口保持一致，如果服务器有多个web服务，可以添加多个server到nginx.conf中 启动nginx1service nginx start 现在我们直接在浏览器输入服务端的地址就能访问到我们的服务端了]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>nginx</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
